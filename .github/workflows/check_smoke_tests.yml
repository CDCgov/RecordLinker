name: check smoke tests

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  service-set-up:
    runs-on: ubuntu-latest

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Convert repository name to lowercase
        run: echo "REPO=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull and push database images to GHCR
        run: |
          for service in "postgres:17" "mysql:8" "mcr.microsoft.com/mssql/server:2022-latest"; do
            image_name=$(echo $service | sed 's|mcr.microsoft.com/mssql/server|mssql|')
            docker pull $service
            docker tag $service ghcr.io/${{ env.REPO }}/$image_name
            docker push ghcr.io/${{ env.REPO }}/$image_name
          done

  smoke_tests:
    runs-on: ubuntu-latest
    needs: service-set-up

    strategy:
      matrix:
        database: [postgres, sqlite, mysql, sqlserver]

    services:
      postgres:
        image: ghcr.io/${{ env.REPO }}/postgres:17
        ports:
          - 5432:5432
        env:
          POSTGRES_PASSWORD: pw

      mysql:
        image: ghcr.io/${{ env.REPO }}/mysql:8
        ports:
          - 3306:3306
        env:
          MYSQL_ROOT_PASSWORD: pw

      sqlserver:
        image: ghcr.io/${{ env.REPO }}/mssql:2022-latest
        ports:
          - 1433:1433
        env:
          ACCEPT_EULA: Y
          SA_PASSWORD: "YourStrong!Passw0rd"

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Convert repository name to lowercase
        run: echo "REPO=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push RecordLinker image
        uses: docker/build-push-action@v3
        with:
          push: true
          tags: ghcr.io/${{ env.REPO }}/rl-service:latest

      - name: Start RecordLinker Service and Run Smoke Tests
        run: |
          # Set database connection URI
          case "${{ matrix.database }}" in
            postgres)  DB_URI="postgresql+psycopg2://postgres:pw@localhost:5432/postgres" ;;
            sqlite)    DB_URI="sqlite:///testdb.sqlite3" ;;
            mysql)     DB_URI="mysql+pymysql://root:pw@localhost:3306/mysql" ;;
            sqlserver) DB_URI="mssql+pyodbc://sa:YourStrong!Passw0rd@localhost:1433/master?driver=ODBC+Driver+18+for+SQL+Server&TrustServerCertificate=yes" ;;
          esac

          # Start Record Linker Service
          docker run -d --name rl-service \
            --network="host" \
            -e DB_URI=$DB_URI \
            ghcr.io/${{ env.REPO }}/rl-service:latest

          # Wait for RL Service to be healthy
          for i in {1..5}; do
            curl -s http://localhost:8080/ | grep "OK" && break
            echo "Waiting for RL Service... Attempt $i/5"
            sleep 5
          done || { echo "RL Service did not become healthy."; exit 1; }

          # Function to send request and validate response
          send_request() {
            local json_body="$1"
            local expected_prediction="$2"
            local check_reference="$3"
            local prev_person_reference_id="$4"

            RESPONSE=$(curl -s -X POST http://localhost:8080/link \
              -d "$json_body" \
              -H "Content-Type: application/json")

            echo "Response: $RESPONSE"

            # Validate the prediction
            echo "$RESPONSE" | jq -e --arg expected "$expected_prediction" '.prediction == $expected'

            # If checking person_reference_id, compare it to the previous one
            if [[ "$check_reference" == "true" ]]; then
              echo "$RESPONSE" | jq -e --arg id "$prev_person_reference_id" '.person_reference_id == $id'
            fi

            # Extract and return person_reference_id
            echo "$RESPONSE" | jq -r '.person_reference_id'
          }

          # Define JSON payloads
          JSON_BODY_1='{"record": {"birth_date": "2013-11-07", "sex": "M", "identifiers":[{"value": "123456789", "type": "MR"}], "name":[{"family":"Shepard", "given":["John"]}]}}'
          JSON_BODY_2='{"algorithm": "dibbs-default", "record": {"birth_date": "2000-12-06", "sex": "M", "identifiers":[{"value": "9876543210", "type": "MR"}], "name":[{"family":"Smith", "given":["William"]}]}}'

          # Run basic tests
          PERSON_REFERENCE_ID_1=$(send_request "$JSON_BODY_1" "no_match" "false")
          send_request "$JSON_BODY_1" "match" "true" "$PERSON_REFERENCE_ID_1"

          # Run enhanced tests
          PERSON_REFERENCE_ID_2=$(send_request "$JSON_BODY_2" "no_match" "false")
          send_request "$JSON_BODY_2" "match" "true" "$PERSON_REFERENCE_ID_2"

          # Run invalid test
          RESPONSE_INVALID=$(curl -s -X POST http://localhost:8080/link \
            -d '{"algorithm": "invalid", "record": {}}' \
            -H "Content-Type: application/json")

          echo "Response: $RESPONSE_INVALID"
          echo "$RESPONSE_INVALID" | grep -q "No algorithm found"
